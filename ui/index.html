<!DOCTYPE html>
<html>
<head>
<title>Mage Knight</title>
<script src="jquery.js"></script>
<script>

function imgUrl(x) { return '/img/' + x + '.png'; }

function tileUrl(ty,n )   { return imgUrl('maps/' + ty + '/' + n); }
function charUrl(ch,ty)   { return imgUrl('characters/' + ch + '/' + ty); }
function enemyUrl(ty,ch)  { return imgUrl('enemies/' + ty + '/' + ch); }
function ruinsUrl(name)   { return imgUrl('ruins/' + name); }
function manaUrl(mana)    { return imgUrl('mana/' + mana); }
function timeUrl(when)    { return imgUrl('time/' + when); }

function boardToken(wi,url) {
  return $('<img/>')
         .css('position', 'absolute')
         .css('width', wi + 'px')
         .css('height', wi + 'px')
         .attr('src', url);
}

function characterToken(m,ch) {
  return boardToken(m.charWidth, charUrl(ch,'figure'));
}

function shieldToken(m,ch) {
  return boardToken(m.shieldWidth, charUrl(ch,'shield'));
}

function enemyToken(m,ty,ch) {
  return boardToken(m.enemyWidth, enemyUrl(ty,ch));
}

function ruinsToken(m,name) {
  return boardToken(m.enemyWidth, ruinsUrl(name));
}



// Compute various dimensions, for the given maximum width and height
// (in hex-grid coordinates)
function prepareMap(pMaxX, pMaxY, pTileWidth) {

  var tileWidth    = pTileWidth;
  var hexWidth     = tileWidth / 3;
  var enemyWidth   = 3 * hexWidth / 4;
  var charWidth    = hexWidth / 1.5;
  var shieldWidth  = hexWidth / 3;

  var centerToSide = hexWidth / 2;
  var hexSide      = centerToSide / Math.sin(Math.PI/ 3);
  var hexHeight    = 2 * hexSide;

  var maxX         = pMaxX;
  var maxY         = pMaxY;
  var x_off        = maxY * centerToSide;
  var y_off        = maxX * 3 * hexSide  + maxY * 4.5 * hexSide;

  return { tileWidth    : tileWidth
         , hexWidth     : hexWidth
         , enemyWidth   : enemyWidth
         , charWidth    : charWidth
         , shieldWidth  : shieldWidth

         , centerToSide : centerToSide
         , hexSide      : hexSide
         , hexHeight    : hexHeight

         , maxX         : maxX
         , maxY         : maxY
         , x_off        : x_off
         , y_off        : y_off
         };
}

// Convert from tile-grid coordinates, to screen coordinates.
function tilePos(m,x,y) {
  return { left: m.x_off + x * 2 * m.hexWidth - y * m.centerToSide
         , top:  m.y_off - x * 3 * m.hexSide  - y * 4.5 * m.hexSide
         };
}

// Compute the location of an individual hex in a tile.
function hexLocation(m, x, y, dir) {
  var coords = tilePos(m,x,y);
  var dX, dY;
  switch(dir) {
    case 'NW': dX = 1; dY = 0; break;
    case 'NE': dX = 3; dY = 0; break;
    case 'W' : dX = 0; dY = 1; break;
    case 'C' : dX = 2; dY = 1; break;
    case 'E' : dX = 4; dY = 1; break;
    case 'SW': dX = 1; dY = 2; break;
    case 'SE': dX = 3; dY = 2; break;
  }
  return { top:  coords.top  + dY * 1.5 * m.hexSide
         , left: coords.left + dX * m.centerToSide
         };
}

// Place some items on the given hex.
//   - `lower` indicates that the items should be be placed at the
//      bottom of the hex (e.g., shields)
//   - the `items` are a collection of DOM elements.
function positionItems(m, items, x, y, dir, lower) {
  var c = hexLocation(m,x,y,dir);
  var hexCenter = c.left + m.hexWidth / 2;

  var totWidth = 0;
  jQuery.each(items,function(ix,item) { totWidth += item.width(); })

  var maxW = 1.5 * m.hexWidth;
  var scaling = 1;
  if (totWidth > maxW) { scaling = maxW / totWidth; totWidth = maxW; }

  var left = hexCenter - totWidth / 2;

  jQuery.each(items,function(ix,item) {
    var h = lower ? (3/4) : (1/2);
    item.css('left', left)
        .css('top',  c.top + h * (m.hexHeight - item.height()));
    left += item.width() * scaling;
  });

}

// Draw a tile on the map.
//   - a `tile` is of type: { x, y: tile-grid coordinates
//                          , tile: { name, type }
//                          , content: [ content ]
//                          }
//
//  XXX: Currnetly, this code assumes that we are drawing a "wedge" type map.
//  The assumption ahs to do with drawing the "ocean" around the map's edges.
function drawTile(m, t) {

  var x      = t.x;
  var y      = t.y;
  var coords = tilePos(m,x,y);
  var left   = coords.left;
  var top    = coords.top;

  var img = $('<img/>').css('position','absolute')
                       .width(m.tileWidth)
                       .height(m.tileWidth * 0.96)
                       .css('left', left)
                       .css('top',top);

  img.click(function(ev) {

    var off = img.offset();
    var imX = ev.pageX - off.left;
    var imY = ev.pageY - off.top;

    var rectX   = m.hexWidth;
    var rectY   = 1.5 * m.hexSide;

    var row    = Math.floor(imY / rectY);
    var clickY = imY - row * rectY;
    var even   = row % 2 === 0;
    if (even) imX += m.centerToSide;

    var col    = Math.floor(imX / rectX);
    var clickX = imX - col * rectX;

    if (clickY < m.hexSide / 2)
      var smllPart = m.hexSide / 2;
      var slope = smllPart / m.centerToSide;
      if (clickX < m.centerToSide) {
        if (clickY < smllPart - clickX * slope) {
          --row;
          if (even) --col;
        }
      } else {
        clickX -= m.centerToSide;
        if (clickY < clickX * slope) {
          --row;
          if (!even) ++col;
        }
      }
    ++row;

    var table = [ [ [0,1,'SW'],  [0,1,'SE'], [1,1,'W'] ]
                , [ [-1,1,'E'],  [0,0,'NW'], [0,0,'NE'],[1,0,'SW'] ]
                , [ [0,0,'W'],   [0,0,'C'],  [0,0,'E'] ]
                , [ [-1,0,'NE'], [0,0,'SW'], [0,0,'SE'],[1,-1,'W'] ]
                , [ [-1,0,'E'],  [0,-1,'NW'],[0,-1,'NE'] ]
                ]
    var diff = table[row][col];
    var cX = x + diff[0];
    var cY = y + diff[1];
    var dir = diff[2];
    if (cX >= 0 && cY >= 0) { return tileClicked(m,cX,cY,dir); return true; }
    return false;
  });


  var imgs = [ img ]; /*
  if (x == 0) imgs.push(drawTile(m,{ tile: {type: 'basic', name: 'border-left'}
                                   , x: -1,y: y+1
                                   , content: []
                                   })[0]);
  if (y == 0) imgs.push(drawTile(m,{ tile: {type: 'basic', name:'border-bottom'}
                                   , x: x+1, y: -1
                                   , content: []
                                   })[0]); */

  img.attr('src',tileUrl(t.tile.tile.type,t.tile.tile.name));

  jQuery.each(t.tile.content, function(ix,c) {
    var deco = drawTileContent(m,x,y,c.location,c.content);
    jQuery.each(deco, function(ix,d) { imgs.push(d); });
  });

  return imgs;
}


// Draw the various things on a hex in tile.
function drawTileContent(m,x,y,dir,c) {
  var items = [];

  if (c.ruins !== null) {
    items.push(ruinsToken(m,c.ruins));
  }

  jQuery.each (c.players, function(ix,player) {
    items.push (characterToken(m,player));
  });

  jQuery.each (c.enemies, function(ix,enemy) {
    items.push (enemyToken(m, enemy.type, enemy.name));
  });

  positionItems(m, items, x, y, dir, false);

  var shields = [];
  jQuery.each (c.shields, function(ix,player) {
    var s = shieldToken(m,player);
    shields.push(s);
    items.push(s);
  });

  positionItems(m, shields, x, y, dir, true);

  return items;
}


// What to do when a tile is clicked.
function tileClicked(m,x,y,dir) {
  jQuery.getJSON('/click', { tile_x: x, tile_y: y, hex: dir }, drawGame);
}


function drawMap(map) {
  var div = $('<div/>')
            .css('position', 'fixed')
            .css('top', '0px')
            .css('left', '0px')
            .css('z-index', '1')
            .css('width', '50%')
            .css('overflow', 'auto')
            .css('background', 'black');

  var maxX = 0;
  var maxY = 0;

  jQuery.each(map, function(ix,tile) {
    if (tile.x > maxX) maxX = tile.x;
    if (tile.y > maxY) maxY = tile.y;
  });

  var m = prepareMap(maxX,maxY,300);
  div.css('height', $(window).height() - 30);

  jQuery.each(map, function(ix,tile) {
    div.append(drawTile(m,tile));
  });

  return div;
}


function focusMap(m,map,x,y) {
  var c = tilePos(m,x,y);
  map.scrollTop(c.top).scrollLeft(c.left);
}




function drawSource(manas) {
  var source = $('<div/>');
  jQuery.each(manas, function(ix,mana) {
    var img = $('<img/>')
              .attr('src', manaUrl(mana))
              .css('display', 'inline-block')
              .css('box-shadow', '2px 2px 5px #ccc')
              .css('margin', '2px')
              .width('20px');
    source.append(img);
  });
  return source;
}

function drawGame(game) {
  $('body').empty()
           .append(drawLand(game.land));
}

function drawLand(land) {
  var time = $('<img/>')
             .attr('src', timeUrl(land.time))
             .css('position','fixed')
             .css('right', '0px')
             .css('top', '  0px')
             .css('z-index', '0');

  var map  = drawMap(land.map);

  var next = $('<div/>')
             .css('position','fixed')
             .css('left', '5px')
             .css('top', '5px')
             .css('z-index', '2');
  jQuery.each(land.nextTiles, function(ix,ty) {
    var t = $('<img/>')
            .width('32px')
            .height('32px')
            .css('display', 'inline-block')
            .attr('src', tileUrl(ty,'back'));
    next.append(t);
  });

  return [map,time,next];
}


$(document).ready(function() {

  jQuery.getJSON('/newGame', {}, function(game) {
    console.log(game);
    drawGame(game);
  });


});
</script>
</head>
<body>
</body>
</html>
