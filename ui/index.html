<!DOCTYPE html>
<html>
<head>
<title>Mage Knight</title>
<style>
@font-face {
  font-family: 'Almendra';
  src: url('/fonts/Almendra-Bold.ttf');
}
</style>
<script src="jquery.js"></script>
<script src="player.js"></script>
<script>

function imgUrl(x)        { return '/img/' + x + '.png'; }

function tileUrl(ty,n )   { return imgUrl('maps/' + ty + '/' + n); }
function charUrl(ch,ty)   { return imgUrl('characters/' + ch + '/' + ty); }
function enemyUrl(ty,ch)  { return imgUrl('enemies/' + ty + '/' + ch); }
function ruinsUrl(name)   { return imgUrl('ruins/' + name); }
function manaUrl(mana)    { return imgUrl('mana/' + mana); }
function timeUrl(when)    { return imgUrl('time/' + when); }
function levelUrl(which)  { return imgUrl('level/' + which); }
function deedUrl(nm)      { return '/deed/' + nm; }
function cardIconUrl(nm)  { return imgUrl('cards/icons/' + nm); }

function boardToken(wi,url) {
  return $('<img/>')
         .css('position', 'absolute')
         .css('width', wi + 'px')
         .css('height', wi + 'px')
         .attr('src', url);
}

function characterToken(m,ch) {
  return boardToken(m.charWidth, charUrl(ch,'figure'))
         .css('z-index', '3');
}

function shieldToken(m,ch) {
  return boardToken(m.shieldWidth, charUrl(ch,'shield'));
}

function enemyToken(m,ty,ch) {
  return boardToken(m.enemyWidth, enemyUrl(ty,ch))
         .css('z-index', '2');
}

function ruinsToken(m,name) {
  return boardToken(m.enemyWidth, ruinsUrl(name));
}



// Compute various dimensions, for the given maximum width and height
// (in hex-grid coordinates)
function prepareMap(pMaxX, pMaxY, pTileWidth) {

  var tileWidth    = pTileWidth;
  var hexWidth     = tileWidth / 3;
  var enemyWidth   = 3 * hexWidth / 4;
  var charWidth    = hexWidth / 1.5;
  var shieldWidth  = hexWidth / 3;

  var centerToSide = hexWidth / 2;
  var hexSide      = centerToSide / Math.sin(Math.PI/ 3);
  var hexHeight    = 2 * hexSide;

  var maxX         = pMaxX;
  var maxY         = pMaxY;
  var x_off        = maxY * centerToSide;
  var y_off        = maxX * 3 * hexSide  + maxY * 4.5 * hexSide;

  return { tileWidth    : tileWidth
         , hexWidth     : hexWidth
         , enemyWidth   : enemyWidth
         , charWidth    : charWidth
         , shieldWidth  : shieldWidth

         , centerToSide : centerToSide
         , hexSide      : hexSide
         , hexHeight    : hexHeight

         , maxX         : maxX
         , maxY         : maxY
         , x_off        : x_off
         , y_off        : y_off
         };
}

// Convert from tile-grid coordinates, to screen coordinates.
function tilePos(m,x,y) {
  return { left: m.x_off + x * 2 * m.hexWidth - y * m.centerToSide
         , top:  m.y_off - x * 3 * m.hexSide  - y * 4.5 * m.hexSide
         };
}

// Compute the location of an individual hex in a tile.
function hexLocation(m, x, y, dir) {
  var coords = tilePos(m,x,y);
  var dX, dY;
  switch(dir) {
    case 'NW': dX = 1; dY = 0; break;
    case 'NE': dX = 3; dY = 0; break;
    case 'W' : dX = 0; dY = 1; break;
    case 'C' : dX = 2; dY = 1; break;
    case 'E' : dX = 4; dY = 1; break;
    case 'SW': dX = 1; dY = 2; break;
    case 'SE': dX = 3; dY = 2; break;
  }
  return { top:  coords.top  + dY * 1.5 * m.hexSide
         , left: coords.left + dX * m.centerToSide
         };
}

// Place some items on the given hex.
//   - `lower` indicates that the items should be be placed at the
//      bottom of the hex (e.g., shields)
//   - the `items` are a collection of DOM elements.
function positionItems(m, items, x, y, dir, lower) {
  var c = hexLocation(m,x,y,dir);
  var hexCenter = c.left + m.hexWidth / 2;

  var totWidth = 0;
  jQuery.each(items,function(ix,item) { totWidth += item.width(); })

  var maxW = 1.5 * m.hexWidth;
  var scaling = 1;
  if (totWidth > maxW) { scaling = maxW / totWidth; totWidth = maxW; }

  var left = hexCenter - totWidth / 2;

  jQuery.each(items,function(ix,item) {
    var h = lower ? (3/4) : (1/2);
    item.css('left', left)
        .css('top',  c.top + h * (m.hexHeight - item.height()))
        .click(function () { tileClicked(m,x,y,dir); });
    left += item.width() * scaling;
  });

}

// Draw a tile on the map.
//   - a `tile` is of type: { x, y: tile-grid coordinates
//                          , tile: { name, type }
//                          , content: [ content ]
//                          }
//
//  XXX: Currnetly, this code assumes that we are drawing a "wedge" type map.
//  The assumption ahs to do with drawing the "ocean" around the map's edges.
function drawTile(m, t) {

  var x      = t.x;
  var y      = t.y;
  var coords = tilePos(m,x,y);
  var left   = coords.left;
  var top    = coords.top;

  var img = $('<img/>').css('position','absolute')
                       .width(m.tileWidth)
                       .height(m.tileWidth * 0.96)
                       .css('left', left)
                       .css('top',top);

  img.click(function(ev) {

    var off = img.offset();
    var imX = ev.pageX - off.left;
    var imY = ev.pageY - off.top;

    var rectX   = m.hexWidth;
    var rectY   = 1.5 * m.hexSide;

    var row    = Math.floor(imY / rectY);
    var clickY = imY - row * rectY;
    var even   = row % 2 === 0;
    if (even) imX += m.centerToSide;

    var col    = Math.floor(imX / rectX);
    var clickX = imX - col * rectX;

    if (clickY < m.hexSide / 2)
      var smllPart = m.hexSide / 2;
      var slope = smllPart / m.centerToSide;
      if (clickX < m.centerToSide) {
        if (clickY < smllPart - clickX * slope) {
          --row;
          if (even) --col;
        }
      } else {
        clickX -= m.centerToSide;
        if (clickY < clickX * slope) {
          --row;
          if (!even) ++col;
        }
      }
    ++row;

    var table = [ [ [0,1,'SW'],  [0,1,'SE'], [1,1,'W'] ]
                , [ [-1,1,'E'],  [0,0,'NW'], [0,0,'NE'],[1,0,'SW'] ]
                , [ [0,0,'W'],   [0,0,'C'],  [0,0,'E'] ]
                , [ [-1,0,'NE'], [0,0,'SW'], [0,0,'SE'],[1,-1,'W'] ]
                , [ [-1,0,'E'],  [0,-1,'NW'],[0,-1,'NE'] ]
                ]
    var diff = table[row][col];
    var cX = x + diff[0];
    var cY = y + diff[1];
    var dir = diff[2];
    if (cX >= 0 && cY >= 0) { return tileClicked(m,cX,cY,dir); return true; }
    return false;
  });


  var imgs = [ img ]; /*
  if (x == 0) imgs.push(drawTile(m,{ tile: {type: 'basic', name: 'border-left'}
                                   , x: -1,y: y+1
                                   , content: []
                                   })[0]);
  if (y == 0) imgs.push(drawTile(m,{ tile: {type: 'basic', name:'border-bottom'}
                                   , x: x+1, y: -1
                                   , content: []
                                   })[0]); */

  img.attr('src',tileUrl(t.tile.tile.type,t.tile.tile.name));

  jQuery.each(t.tile.content, function(ix,c) {
    var deco = drawTileContent(m,x,y,c.location,c.content);
    jQuery.each(deco, function(ix,d) { imgs.push(d); });
  });

  return imgs;
}


// Draw the various things on a hex in tile.
function drawTileContent(m,x,y,dir,c) {
  var items = [];

  if (c.ruins !== null) {
    items.push(ruinsToken(m,c.ruins));
  }

  jQuery.each (c.players, function(ix,player) {
    items.push (characterToken(m,player));
  });

  jQuery.each (c.enemies, function(ix,enemy) {
    items.push (enemyToken(m, enemy.type, enemy.name));
  });

  positionItems(m, items, x, y, dir, false);

  var shields = [];
  jQuery.each (c.shields, function(ix,player) {
    var s = shieldToken(m,player);
    shields.push(s);
    items.push(s);
  });

  positionItems(m, shields, x, y, dir, true);

  items.push(drawHexShadow(m,x,y,dir));

  return items;
}


function drawHexShadow(m,x,y,dir) {
  var l = hexLocation(m, x, y, dir);
  var poly = 'polygon(50% 0, 100% 25%, 100% 75%, 50% 100%, 0 75%, 0 25%)';
  var img = $('<div/>')
          .css('width', m.hexWidth + 'px')
          .css('height', m.hexHeight + 'px')
          .css('position', 'absolute')
          .css('z-index', '4')
          .css('left', l.left)
          .css('top', l.top)
          .css('background-color', 'rgba(255,255,255,0.3)')
          .css('-webkit-clip-path', poly)
          .css('clip-path', poly);


   img.mousemove(function(ev) {
      console.log('move',x,y,dir);
   });

  return img;
}

// What to do when a tile is clicked.
function tileClicked(m,x,y,dir) {
  jQuery.getJSON('/click', { tile_x: x, tile_y: y, hex: dir }, drawGame);
}


function drawMap(map, p, lastSafe) {
  var div = $('<div/>')
            .css('position', 'fixed')
            .css('top', '0px')
            .css('left', '0px')
            .css('z-index', '1')
            .css('width', '50%')
            .css('overflow', 'auto')
            .css('background', 'black');

  var maxX = 0;
  var maxY = 0;

  jQuery.each(map, function(ix,tile) {
    if (tile.x > maxX) maxX = tile.x;
    if (tile.y > maxY) maxY = tile.y;
  });

  var m = prepareMap(maxX,maxY,300);
  div.css('height', $(window).height() - 30);

  jQuery.each(map, function(ix,tile) {
    div.append(drawTile(m,tile));
  });

  if (lastSafe !== null) {
    var x = lastSafe.x;
    var y = lastSafe.y;
    var dir = lastSafe.hex;
    var deco = characterToken(m, p)
               .css('opacity', '0.75');
    positionItems(m, [deco], x, y, dir, false);
    div.append(deco);
  }

  return { dom: div, focus: function(x,y) { focusMap(m,div,x,y); } };
}


function focusMap(m,map,x,y) {
  var c = tilePos(m,x,y);
  var w = map.width();
  var h = map.height();
  map.scrollTop(c.top   - (h - m.tileWidth) / 2)
     .scrollLeft(c.left - (w - m.tileWidth) / 2);
}




function drawSource(manas) {
  var source = $('<div/>');
  jQuery.each(manas, function(ix,mana) {
    var img = $('<img/>')
              .attr('src', manaUrl(mana))
              .css('display', 'inline-block')
              .css('box-shadow', '2px 2px 5px #ccc')
              .css('margin', '2px')
              .width('20px');
    source.append(img);
  });
  return source;
}

function drawGame(game) {
  var p = game.player;
  var l = drawLand(game.land, p.name, p.unsafe);
  $('body').empty().append(l.dom, drawPlayer(p));
  var loc = p.location;
  l.focus(loc.x, loc.y);
  console.log(game.player);
}

function drawLand(land, p, lastSafe) {
  var time = $('<img/>')
             .attr('src', timeUrl(land.time))
             .css('position','fixed')
             .css('width', '5em')
             .css('right', '0px')
             .css('top', '  0px')
             .css('z-index', '0');

  var map  = drawMap(land.map, p, lastSafe);

  var next = $('<div/>')
             .css('position','fixed')
             .css('left', '5px')
             .css('top', '5px')
             .css('z-index', '2');
  jQuery.each(land.nextTiles, function(ix,ty) {
    var t = $('<img/>')
            .width('32px')
            .height('32px')
            .css('display', 'inline-block')
            .attr('src', tileUrl(ty,'back'));
    next.append(t);
  });

  return { dom: [map.dom,time,next], focus: map.focus }
}



function deedCardImage(name) {

  // var sizes = [ 160, 264 ];
  var sizes = [ 264 ];
  var curW  = 0;


  var me = $('<div/>')
           .css('box-shadow', '0px 0px 2px 2px orange')
           .css('position', 'absolute')
           .css('background-image', 'url("' + deedUrl(name) + '")')
           .data('name', name);

  function setW() {
    var w = sizes[curW];
    var h = 1.5 * w;
    me.width(w).height(h);
    me.css('background-size', w + 'px ' + h + 'px')
  }

  function focus() {
    me.css('z-index', '2')
    me.siblings().css('z-index', '1');
  }

  me.click(function(ev) {
    if (me.css('z-index') == '1') {
      focus();
    } else {
     curW = (curW + 1) % sizes.length;
     setW();
    }
   return false;
  });

  me.selectCard = function() { focus(); }

  setW();
  return me;
}


function sidewaysCardImage(name) {
  var me = deedCardImage(name)
           .css('transform', 'rotate(90deg)');
  return me;
}


function actionCard(name, poweredUp) {
  var me = deedCardImage(name);
  var pos = poweredUp ? (7/12) : (9/11);

  var screen = $('<div/>')
               .width(me.width())
               .height(me.height()/7)
               .css('position','absolute')
               .css('left','0px')
               .css('top', (pos * me.height()) + 'px')
               .css('background-color', 'rgba(0,0,0,0.75)');
  return me.append(screen);
}

function spellCard(name, poweredUp) {
  var me = deedCardImage(name);
  var pos = poweredUp ? 0 : (1/2);

  var screen = $('<div/>')
               .width(me.width())
               .height(me.height()/2)
               .css('position','absolute')
               .css('left','0px')
               .css('top', (pos * me.height()) + 'px')
               .css('background-color', 'rgba(0,0,0,0.75)');
  return me.append(screen);
}




function drawCardContainer(vscale) {
  var me = $('<div/>')
           .css('padding', '0')
           .css('margin',  '0')
           .css('position', 'relative');


  me.addCard = function(img) {
    me.append(img);
    jQuery.each(me.children(), function(ix,x) {
      var x = $(x);
      x.css('top', (ix * x.height() / vscale));
    });
    img.selectCard();
  }

  me.curCard = function() {
    var res = null;
    jQuery.each(me.children(), function(ix,img) {
      img = $(img);
      if (img.css('z-index') == '2') { res = img.data('name'); return false; }
    });
    return res;
  }

  return me;
  ;
}

function drawHand(cardNames) {
  var me = drawCardContainer(1.7);
  jQuery.each(cardNames, function(ix,cardName) {
    var c = deedCardImage(cardName);
    var playMenu = $('<div/>')
                   .css('text-align', 'center')
                   .css('background-color', 'rgba(0,0,0,0.5)')
                   .css('color', 'white');

    var sidewaysMenu =
        $('<div/>')
        .css('text-align','right')
        .css('background-color', 'rgba(0,0,0,0.5)')
        .css('color', 'white')
        .hide();

    function textButton(label, click) {
      return $('<div/>')
             .html(label)
             .css('margin-right', '16px')
             .css('cursor', 'pointer')
             .css('font-family', 'Almendra')
             .css('height', '18px')
             .css('display','inline-block')
             .click(click);
    }

    if (cardName === 'Wound') {
      playMenu.append(
        $('<img/>')
        .attr('src', cardIconUrl('heal'))
        .css('cursor', 'pointer')
        .css('margin', '2px')
        .css('width','16px')
        .css('height','18px')
        .click(function(ev) {
          console.log('heal wound')
          return false;
        })
      );
    } else {
      playMenu
        .append(
          textButton('&#x21b7;', function(ev) {
            playMenu.hide();
            sidewaysMenu.show();
            c.css('transform', 'rotate(90deg)');
            return false;
          })
          .css('position', 'absolute')
          .css('right', '0')
        )
        .append (
          textButton('&#x27a1;', function(ev) {
            console.log('play ' + cardName);
            return false;
          })
        );
    }
   function sideButton(name) {
      var sideways = 0;
      var btn = $('<img/>')
                .attr('src', cardIconUrl(name))
                .css('cursor', 'pointer')
                .css('margin', '2px')
                .css('width','16px')
                .css('height','18px')
                .css('transform', 'rotate(-90deg)')
                .click(function(ev) {
                  console.log('play ' + cardName + ' for ' + name);
                  return false;
                });
      sidewaysMenu.append(btn);
   }

   sidewaysMenu.append(
    textButton('&#x21b6;', function(ev) {
      sidewaysMenu.hide();
      playMenu.show();
      c.css('transform', 'rotate(0deg)');
      return false;
    })
   );
   sideButton('move');
   sideButton('influence');
   sideButton('attack');
   sideButton('block');

    c.append(playMenu)
     .append(sidewaysMenu);

    me.addCard(c);
  });
  return me;
}




function drawPlayArea(hand) {
  var me = $('<div/>')
           .css('background-color', 'rgba(0,0,0,0.7)')
           .css('border', '1px solid black')
           .css('min-width',  '250px')
           .css('min-height', '250px')
           .css('position', 'fixed')
           .css('right', '10px')
           .css('top',   '10px');
  me.click(function() {
    var it = hand.curCard();
    if (it === null) return;
    alert(it);
  });

  //me.append(sidewaysCardImage('Mana Draw'));
  me.append(spellCard('Burning Shield', false));
  me.append(actionCard('March', false));
  return me;
}

$(document).ready(function() {

/*
  var body = $('body');
  var h = drawHand(
    [ 'Wound',  'Wound', 'March', 'Crystallize' ]
  );

  body.append(h);
  body.append(drawPlayArea(h));

  return;
  */
  jQuery.getJSON('/newGame', {}, function(game) {
    console.log(game);
    drawGame(game);
  });


});
</script>
</head>
<body>
</body>
</html>
